## Python - core
https://www.tutorialspoint.com


##################################################################   INDEX       ########################################

1.  Chapter1: General Rules
2.  Chapter2: Frequently Used Commands
3.  Chapter3: Python Standard Data Types
4.  Chapter4: Assigning Values to Variables
5.  Chapter5: Types of Operator
6.  Chapter6: Loops
7.  Chapter7: Python Date & Time
8.  Chapter8: Defining a Function
9.  Chapter9: The Anonymous Functions (lambda)
10. Chapter10: Scope of a variable
11. Chapter11: Python Modules
12. Chapter12: Python Files I/O
13. Chapter13: Python Exception - pending
14. Chapter14: Python Classes/Objects
15. Chapter15: Python Sending Email
16. Chapter16: Python Threading, Multithreaded Programming
17. Chapter17: k12Ref

################################################################### Chapter1: General Rules    ############################
## Python Identifiers
A Python identifier is a name used to identify a variable, function, class, module or other object
Here are naming conventions for Python identifiers:
a. Class names start with an uppercase letter. All other identifiers start with a lowercase letter.
b. Starting an identifier with a single leading underscore indicates that the identifier is private.
c. Starting an identifier with two leading underscores indicates a strongly private identifier.
d. If the identifier also ends with two trailing underscores, the identifier is a language-defined special name

## Lines and Indentation
Python provides no braces to indicate blocks of code for class and function definitions or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced. The number of spaces in the indentation is variable, but all statements within the block must be
indented the same amount. 
Ex:
if True:
	print "Answer"
	print "True"
else:
	print "Answer"
	print "False"

## Multi-Line Statements
Statements in Python typically end with a new line. Python does, however, allow the use of the line continuation character (\) to denote that the line should continue.
Ex: 
total = item_one + \
		item_two + \
		item_three

Statements contained within the [], {}, or brackets do not need to use the line continuation character. For example -
days = ['Monday', 'Tuesday', 'Wednesday',
'Thursday', 'Friday']	

## Quotation in Python
Python accepts single ', double " and triple ? quotes to denote string literals, as long as the same type of quote starts and ends the string.
The triple quotes are used to span the string across multiple lines. For example, all the following are legal -
Ex: 
word = 'word'
sentence = "This is a sentence."
paragraph = """This is a paragraph. It is
made up of multiple lines and sentences."""

## Comments in Python
A hash sign # that is not inside a string literal begins a comment. All characters after the # and up to the end of the physical line are part of the comment and the Python interpreter ignores them.
Ex: 
#!/usr/bin/python
# First comment
print "Hello, Python!" # second comment

## Waiting for the User
The following line of the program displays the prompt, the statement saying “Press the enter key to exit”, and waits for the user to take action
Ex: 
>>> raw_input("\n enter string: ")
 enter string: Hi
'Hi'

## Multiple Statements on a Single Line
The semicolon ; allows multiple statements on the single line given that neither statement starts a new code block. Here is a sample snip using the semicolon:
import sys; x = 'foo'; sys.stdout.write(x + '\n')

## Multiple Statement Groups as Suites
A group of individual statements, which make a single code block are called suites in Python. Compound or complex statements, such as if, while, def, and class require a header line and a suite. Header lines begin the statement with the keyword and terminate with a colon : and are followed
by one or more lines which make up the suite. 

Ex: 
if expression :
	suite
elif expression :
	suite
else :
	suite

## Command Line Arguments
Many programs can be run to provide you with some basic information about how they should be run
$ python -h
	
################################################################### Chapter2: Frequently Used Commands ########################	

1. Login
$ python
>>> 
2. Quit
>>> quit()
3. File extension is fiel1.py
4. Execution $ python fiel1.py
5. Install IDLE on linux. This is kind of an IDE for Python, it will be useful.
	https://www.youtube.com/watch?v=HJjmlevMjio&index=2&list=PL51A2A33163D53FD9
	a. To install in REDHAT, sudo yum install idle
	b. To install in ubuntu, sudo apt-get install idle
6. To open the IDLE, just type $ idle 
7. 	In Python, function will start with 'def' and it should return a value. Refer "Chapter8: Defining a Function"
8. 

################################################################### Chapter3: Python Standard Data Types ########################	

# Python has five standard data types -
	a. Numbers (int, long, float, complex)
	b. String
	c. List
	d. Tuple
	e. Dictionary

# a. Numbers (int, long, float, complex)	
10 			# int
51924361L	# long
0.0 		# float
3.14j		# complex

# b. Strings	
str = 'Hello World!'
print str # Prints complete string
print str[0] # Prints first character of the string
print str[2:5] # Prints characters starting from 3rd to 5th
print str[2:] # Prints string starting from 3rd character
print str * 2 # Prints string two times
print str + "TEST" # Prints concatenated string

# c. List
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']
print list # Prints complete list
print list[0] # Prints first element of the list
print list[1:3] # Prints elements starting from 2nd till 3rd
print list[2:] # Prints elements starting from 3rd element
print tinylist * 2 # Prints list two times
print list + tinylist # Prints concatenated lists

This produce the following result -
['abcd', 786, 2.23, 'john', 70.200000000000003]
abcd
[786, 2.23]
[2.23, 'john', 70.200000000000003]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john']

# d. Tuple	
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')
print tuple # Prints complete list
print tuple[0] # Prints first element of the list
print tuple[1:3] # Prints elements starting from 2nd till 3rd
print tuple[2:] # Prints elements starting from 3rd element
print tinytuple * 2 # Prints list two times
print tuple + tinytuple # Prints concatenated lists
This produce the following result -
('abcd', 786, 2.23, 'john', 70.200000000000003)
abcd
(786, 2.23)
(2.23, 'john', 70.200000000000003)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john')

## List Vs Tuple
The main differences between lists and tuples are: Lists are enclosed in brackets [] and their elements and size can be changed, while tuples are enclosed in parentheses ( ) and cannot be updated. Tuples can be thought of as read-only lists. 
Ex:
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
list[2] = 1000 # Valid syntax with list
tuple[2] = 1000 # Invalid syntax with tuple

## Python Dictionary
Python's dictionaries are kind of hash table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any Python type, but are usually numbers or strings. Values, on the other hand

dict = {}
dict['one'] = "This is one"
dict[2] = "This is two"
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print dict['one'] # Prints value for 'one' key
print dict[2] # Prints value for 2 key
print tinydict # Prints complete dictionary
print tinydict.keys() # Prints all the keys
print tinydict.values() # Prints all the values

This produce the following result -

This is one
This is two
{'dept': 'sales', 'code': 6734, 'name': 'john'}
['dept', 'code', 'name']
['sales', 6734, 'john']


################################################################### Chapter4: Assigning Values to Variables ########################	

Python variables do not need explicit declaration to reserve memory space. The declaration happens automatically when you assign a value to a variable.
Ex:
#!/usr/bin/python
counter = 100 # An integer assignment
miles = 1000.0 # A floating point
name = "John" # A string
print counter
print miles
print name

## Multiple Assignment
Python allows you to assign a single value to several variables simultaneously. For example -
Ex: 
>>> a=b=c = 1		## Same value for multiple variables
>>> d,e=5,"John" 	## different values for different variables
>>> print d
5
>>> print e
John
>>> print a
1

## Delete the values from the variables
>>> var1=1
>>> print var1
1
>>> del var1
>>> print var1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'var1' is not defined


## Data Type Conversion
Sometimes, you may need to perform conversions between the built-in types. To convert between types, you simply use the type name as a function.

There are several built-in functions to perform conversion from one data type to another. These functions return a new object representing the converted value.

Function 					Description
intx[, base] 				Converts x to an integer. base specifies the base if x is a string.
longx[, base] 				Converts x to a long integer. base specifies the base if x is a string.
floatx 						Converts x to a floating-point number.
etc

################################################################### Chapter5: Types of Operator ########################		
	
## Python language supports the following types of operators.
	a. Arithmetic Operators
	b. Comparison (Relational) Operators
	c. Assignment Operators
	d. Logical Operators
	e. Bitwise Operators
	f. Membership Operators
	g. Identity Operators	
	
# a. Arithmetic Operators
a = 10 
b = 20
a + b = 30	
a – b = -10	
a * b = 200
b / a = 2
b % a = 0					# Modulus
a**b =10 to the power 20	# Exponent	
# Floor Division: The division of operands where the result is the quotient in which the digits after the decimal point are removed. But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity):
9//2 = 4 and 9.0//2.0 = 4.0, -11//3 = -4, -11.0//3 = -4.0

# b. Python Comparison Operators
a = 10 
b = 20
(a == b) is not true.
(a > b) is not true.
(a < b) is true.
(a >= b) is not true.
(a <= b) is true.

# c. Python Assignment Operators	
c = a + b 	# assigns value of a + b into c
c += a 		# is equivalent to c = c + a
c -= a 		# is equivalent to c = c - a
c *= a 		# is equivalent to c = c * a

# d. Python Logical Operators
(a and b) is true.
(a or b) is true.
Not(a and b) is false.

# e. Bitwise Operators
N/A

# f. Membership Operators
in		# Evaluates to true if it finds a variable in the specified sequence and false otherwise
not in 	# Evaluates to true if it does not finds a variable in the specified sequence and false otherwise.

# g. Identity Operators
is		# Evaluates to true if the variables on either side of the operator point to the same object and false otherwise.
is not	# Evaluates to false if the variables on either side of the operator point to the same object and true otherwise.

Ex:
a = 20
b = 20
if ( a is b ):
   print "Line 1 - a and b have same identity"
else:
   print "Line 1 - a and b do not have same identity"
	
	
################################################################### Chapter6: Loops ###########################			

## While loop
count = 0
while (count < 3):
   print 'The count is:', count
   count = count + 1

print "Good bye!"	
	
it produces the following result -

The count is: 0
The count is: 1
The count is: 2
Good bye!	
	
## The Infinite Loop	
var = 1
while var == 1 :  # This constructs an infinite loop
   num = raw_input("Enter a number  :")
   print "You entered: ", num

print "Good bye!"

it produces the following result -

Enter a number  :20
You entered:  20
Enter a number  :29
You entered:  29
...etc	

## Using else Statement with Loops
count = 0
while count < 5:
   print count, " is  less than 5"
   count = count + 1
else:
   print count, " is not less than 5"
   
## Single Statement Suites
Similar to the if statement syntax, if your while clause consists only of a single statement, it may be placed on the same line as the while header.

flag = 1
while (flag): print 'Given flag is really true!'
print "Good bye!"   


################################################################### Chapter7: Python Date & Time ###########################			

A Python program can handle date and time in several ways

## What is Tick?
Time intervals are floating-point numbers in units of seconds. Particular instants in time are expressed in seconds since 12:00am, January 1, 1970(epoch).

There is a popular time module available in Python which provides functions for working with times, and for converting between representations. The function time.time() returns the current system time in ticks since 12:00am, January 1, 1970(epoch).

Ex:
#!/usr/bin/python
import time;  # This is required to include time module.
ticks = time.time()
print "Number of ticks since 12:00am, January 1, 1970:", ticks

Result:
Number of ticks since 12:00am, January 1, 1970: 1490209363.46

## Getting current time
#!/usr/bin/python
import time;
localtime = time.localtime(time.time())
print "Local current time :", localtime

Result: Local current time : time.struct_time(tm_year=2013, tm_mon=7, 
tm_mday=17, tm_hour=21, tm_min=26, tm_sec=3, tm_wday=2, tm_yday=198, tm_isdst=0)

## Getting formatted time
>>> import time;
>>> loc = time.asctime(time.localtime(time.time()))
>>> print "formatted local time: " , loc

Result: formatted local time:  Wed Mar 22 15:08:25 2017

## Calendar of a month
>>> import calendar
>>> cal = calendar.month(2017,3)
>>> print cal
     March 2017
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31

################################################################### Chapter8: Defining a Function ###########################	

You can define functions to provide the required functionality. Here are simple rules to define a function in Python.

a. Function blocks begin with the keyword def followed by the function name and parentheses ( ( ) ).
b. Any input parameters or arguments should be placed within these parentheses. You can also define parameters inside these parentheses.
c. The first statement of a function can be an optional statement - the documentation string of the function or docstring.
d. The code block within every function starts with a colon (:) and is indented.
e. The statement return [expression] exits a function, optionally passing back an expression to the caller. A return statement with no arguments is the same as return None.

# Syntax
def functionname( parameters ):
   "function_docstring"
   function_suite
   return [expression]

Ex:
# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print str
   return;

# Now you can call printme function
printme("I'm first call to user defined function!")
printme("Again second call to the same function")   
   
## Pass by reference vs value
#!/usr/bin/python
# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist = [1,2,3,4]; # This would assig new reference in mylist
   print "Values inside the function: ", mylist
   return

# Now you can call changeme function
mylist = [10,20,30];
changeme( mylist ); ## This will call the function
print "Values outside the function: ", mylist

The parameter mylist is local to the function changeme. Changing mylist within the function does not affect mylist. The function accomplishes nothing and finally this would produce the following result:

Values inside the function:  [1, 2, 3, 4]
Values outside the function:  [10, 20, 30]


################################################################### Chapter9: The Anonymous Functions (lambda) ###########################	

These lambda functions are called anonymous because they are not declared in the standard manner by using the def keyword. You can use the lambda keyword to create small anonymous functions

a. Lambda forms can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions.
b. An anonymous function cannot be a direct call to print because lambda requires an expression
c. Lambda functions have their own local namespace and cannot access variables other than those in their parameter list and those in the global namespace.
d. Although it appears that lambda's are a one-line version of a function, they are not equivalent to inline statements in C or C++, whose purpose is by passing function stack allocation during invocation for performance reasons.

# Syntax: The syntax of lambda functions contains only a single statement, which is as follows -
lambda [arg1 [,arg2,.....argn]]:expression

Ex:
>>> sum = lambda arg1, arg2: arg1+arg2
>>> print sum(3,5)
8

## Difference between Normal Function & Anonymous Function (lambda)
# Normal function & lambda function explained above
>>> def sum1(arg1, arg2):
...   total = arg1 + arg2
...   return total
...
>>> print sum1(3,5)
8

################################################################### Chapter10: Scope of a variable ###########################	
a. Global variable
b. Local variable

## Global vs. Local variables
Variables that are defined inside a function body have a local scope, and those defined outside have a global scope

#!/usr/bin/python
total = 0; # This is global variable.
# Function definition is here
def sum( arg1, arg2 ):
   # Add both the parameters and return them."
   total = arg1 + arg2; # Here total is local variable.
   print "Inside the function local total : ", total
   return total;

# Now you can call sum function
sum( 10, 20 );
print "Outside the function global total : ", total 

################################################################### Chapter11: Python Modules ###########################	

You can use any Python source file as a module by executing an import statement in some other Python source file. The import has the following syntax:

# Syntax:
import module1[, module2[,... moduleN]

When the interpreter encounters an import statement, it imports the module if the module is present in the search path. A search path is a list of directories that the interpreter searches before importing a module

Ex: 
## Program 1: save it as support.py
def print_func( par ):
   print "Hello : ", par
   return

## Program 2: import support.py
import support
support.print_func("Zara")   

A module is loaded only once, regardless of the number of times it is imported. This prevents the module execution from happening over and over again if multiple imports occur


## The from...import Statement
Python's from statement lets you import specific attributes from a module into the current namespace. The from...import has the following syntax -

# Syntax: 
from modname import name1[, name2[, ... nameN]]

It is also possible to import all names from a module into the current namespace by using the following import statement -

# Syntax:
from modname import *


## Locating Modules
When you import a module, the Python interpreter searches for the module in the following sequences -
	a. The current directory.
	b. If the module isn't found, Python then searches each directory in the shell variable PYTHONPATH.
	c. If all else fails, Python checks the default path. On UNIX, this default path is normally /usr/local/lib/python/

## The PYTHONPATH Variable:
The PYTHONPATH is an environment variable, consisting of a list of directories. The syntax of PYTHONPATH is the same as that of the shell variable PATH.

Here is a typical PYTHONPATH from a Windows system:
set PYTHONPATH=c:\python20\lib;

And here is a typical PYTHONPATH from a UNIX system:
set PYTHONPATH=/usr/local/lib/python	


################################################################### Chapter12: Python Files I/O ###########################	

## Printing to the Screen
print "Python is really a great language,", "isn't it?"

This produces the following result on your standard screen:
Python is really a great language, isn't it?

## Reading Keyboard Input
a. raw_input
b. input

## The raw_input Function
The raw_input([prompt]) function reads one line from standard input and returns it as a string (removing the trailing newline).

str = raw_input("Enter your input: ");
print "Received input is : ", str

## The input Function
The input([prompt]) function is equivalent to raw_input, except that it assumes the input is a valid Python expression and returns the evaluated result to you.

str = input("Enter your input: ");
print "Received input is : ", str

This would produce the following result against the entered input -
Enter your input: [x*5 for x in range(2,10,2)]
Recieved input is :  [10, 20, 30, 40]

## Opening and Closing Files
The open Function
Before you can read or write a file, you have to open it using Python's built-in open() function
Syntax
file object = open(file_name [, access_mode][, buffering])

a. file_name: The file_name argument is a string value that contains the name of the file that you want to access.
b. access_mode: The access_mode determines the mode in which the file has to be opened, i.e., read, write, append, etc. A complete list of possible values is given below in the table. This is optional parameter and the default file access mode is read (r).
c. buffering: If the buffering value is set to 0, no buffering takes place. If the buffering value is 1, line buffering is performed while accessing a file. If you specify the buffering value as an integer greater than 1, then buffering action is performed with the indicated buffer size. If negative, the buffer size is the system default(default behavior).

## Access_mode: Here is a list of the different modes of opening a file -
Modes		Description
r			Opens a file for reading only. The file pointer is placed at the beginning of the file. This is the default mode
w			Opens a file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.
r+			Opens a file for both reading and writing. The file pointer placed at the beginning of the file.
wb 			Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file 				for writing.


# Open a file
fo = open("foo.txt", "wb")
print "Name of the file: ", fo.name			## Returns name of the file.
print "Closed or not : ", fo.closed			## Returns true if file is closed, false otherwise.
print "Opening mode : ", fo.mode			## Returns access mode with which file was opened.
print "Softspace flag : ", fo.softspace		## Returns false if space explicitly required with print, true otherwise


## Reading and Writing Files
The file object provides a set of access methods to make our lives easier. We would see how to use read() and write() methods to read and write files
The write() method writes any string to an open file. It is important to note that Python strings can have binary data and not just text.

# Syntax:
fileObject.write(string);

Example
# Open a file
fo = open("foo.txt", "wb")
fo.write( "Python is a great language.\nYeah its great!!\n");

# Close opend file
fo.close()


##The read() Method

# Open a file
fo = open("foo.txt", "r+")
str = fo.read(10);
print "Read String is : ", str
# Close opend file
fo.close()

## Ex for File position

# Open a file
fo = open("foo.txt", "r+")
str = fo.read(10);
print "Read String is : ", str

# Check current position
position = fo.tell();
print "Current file position : ", position

# Reposition pointer at the beginning once again
position = fo.seek(0, 0);
str = fo.read(10);
print "Again read String is : ", str
# Close opend file
fo.close()

This produces the following result:
Read String is :  Python is
Current file position :  10
Again read String is :  Python is


## The rename() Method
The rename() method takes two arguments, the current filename and the new filename.

# Syntax:
os.rename(current_file_name, new_file_name)

Ex:
import os
os.rename( "test1.txt", "test2.txt" ) # Rename a file from test1.txt to test2.txt

## The remove() Method
You can use the remove() method to delete files by supplying the name of the file to be deleted as the argument.

# Syntax:
os.remove(file_name)

Ex:
import os
os.remove("text2.txt")   # Delete file test2.txt

## The mkdir() Method
You can use the mkdir() method of the os module to create directories in the current directory. You need to supply an argument to this method which contains the name of the directory to be created.

# Syntax:
os.mkdir("newdir")

import os
os.mkdir("test") # Create a directory "test"

## The chdir() Method
You can use the chdir() method to change the current directory. The chdir() method takes an argument, which is the name of the directory that you want to make the current directory.

# Syntax:
os.chdir("newdir")

Ex:
import os
os.chdir("/home/newdir")	 # Changing a directory to "/home/newdir"

## The getcwd() Method
The getcwd() method displays the current working directory.

# Syntax:
os.getcwd()

Ex:
import os
os.getcwd() # This would give location of the current directory

## The rmdir() Method
The rmdir() method deletes the directory, which is passed as an argument in the method.

# Syntax:
os.rmdir('dirname')

ex:
import os
os.rmdir( "/tmp/test"  )  # This would  remove "/tmp/test"  directory.


################################################################### Chapter13: Python Exception ###########################	

<<TBD>>
https://www.tutorialspoint.com/python/python_exceptions.htm


################################################################### Chapter14: Python Classes/Objects #######################	

Python has been an object-oriented language since it existed. 

https://www.tutorialspoint.com/python/python_classes_objects.htm

## Creating Classes
The class statement creates a new class definition. The name of the class immediately follows the keyword class followed by a colon as follows

class ClassName:
   'Optional class documentation string'
   class_suite
   
	a. The class has a documentation string, which can be accessed via ClassName.__doc__.
	b. The class_suite consists of all the component statements defining class members, data attributes and functions.   

# Example: Following is the example of a simple Python class
class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary	

a. The variable empCount is a class variable whose value is shared among all instances of a this class. This can be accessed as Employee.empCount from inside the class or outside the class.
b. The first method __init__() is a special method, which is called class constructor or initialization method that Python calls when you create a new instance of this class.
c. You declare other class methods like normal functions with the exception that the first argument to each method is "self". Python adds the self argument to the list for you; "you do not need to include it when you call the methods".

## Creating Instance Objects
To create instances of a class, you call the class using class name and pass in whatever arguments its __init__ method accepts.

"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)


## Accessing Attributes
You access the object's attributes using the dot operator with object. Class variable would be accessed using class name as follows:

emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount

## Now, putting all the concepts together -

#!/usr/bin/python
class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

"This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
"This would create second object of Employee class"
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount

# When the above code is executed, it produces the following result:
Name :  Zara ,Salary:  2000
Name :  Manni ,Salary:  5000
Total Employee 2
	
## Base Overloading Methods
1. __init__ ( self [,args...] )		## Constructor (with any optional arguments)
2. __del__( self )					## Destructor, deletes an object
3. __repr__( self )					## Evaluatable string representation
4. __str__( self )					## Printable string representation
5. __cmp__ ( self, x )				## Object comparison


################################################################### Chapter15: Python Sending Email #################	
Simple Mail Transfer Protocol (SMTP) is a protocol, which handles sending e-mail and routing e-mail between mail servers.

Python provides smtplib module, which defines an SMTP client session object that can be used to send mail to any Internet machine with an SMTP or ESMTP listener daemon.

## Python Sending Email using SMTP
# Synxtax:
import smtplib
smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )

An SMTP object has an instance method called sendmail, which is typically used to do the work of mailing a message. It takes three parameters -
	a. The sender - A string with the address of the sender.
	b. The receivers - A list of strings, one for each recipient.
	c. The message - A message as a string formatted as specified in the various RFCs

Ex:
import smtplib
sender = 'from@fromdomain.com'
receivers = ['to@todomain.com']
message = """From: From Person <from@fromdomain.com>
To: To Person <to@todomain.com>
Subject: SMTP e-mail test
This is a test e-mail message.
"""
try:
   smtpObj = smtplib.SMTP('localhost')
   smtpObj.sendmail(sender, receivers, message)         
   print "Successfully sent email"
except SMTPException:
   print "Error: unable to send email"
   
## Sending an HTML e-mail using Python
import smtplib
message = """From: From Person <from@fromdomain.com>
To: To Person <to@todomain.com>
MIME-Version: 1.0
Content-type: text/html
Subject: SMTP HTML e-mail test

This is an e-mail message to be sent in HTML format

<b>This is HTML message.</b>
<h1>This is headline.</h1>
"""

try:
   smtpObj = smtplib.SMTP('localhost')
   smtpObj.sendmail(sender, receivers, message)         
   print "Successfully sent email"
except SMTPException:
   print "Error: unable to send email"   

   
##################################################### Chapter16: Python Threading, Multithreaded Programming ################	   

Running several threads is similar to running several different programs concurrently, but with the following benefits -

a. Multiple threads within a process share the same data space with the main thread and can therefore share information or communicate with each other more easily than if they were separate processes.
b. Threads sometimes called light-weight processes and they do not require much memory overhead; they are cheaper than processes.

## The Threading Module:
The newer threading module included with Python 2.4 provides much more powerful, high-level support for threads than the thread module

# The threading module exposes all the methods of the thread module and provides some additional methods:
	a. threading.activeCount(): Returns the number of thread objects that are active.
	b.threading.currentThread(): Returns the number of thread objects in the caller's thread control.
	c. threading.enumerate(): Returns a list of all thread objects that are currently active.

# In addition to the methods, the threading module has the Thread class that implements threading. The methods provided by the Thread class are as follows:
	a. run(): The run() method is the entry point for a thread.
	b. start(): The start() method starts a thread by calling the run method.
	c. join([time]): The join() waits for threads to terminate.
	d. isAlive(): The isAlive() method checks whether a thread is still executing.
	e. getName(): The getName() method returns the name of a thread.
	f. setName(): The setName() method sets the name of a thread.	

# Creating Thread Using Threading Module
To implement a new thread using the threading module, you have to do the following -
	a. Define a new subclass of the Thread class.
	b. Override the __init__(self [,args]) method to add additional arguments.
	c. Then, override the run(self [,args]) method to implement what the thread should do when started.

----------------------------
## Example 1: for Threading
import threading

class SummingThread(threading.Thread):
     def __init__(self,low,high):
         super(SummingThread, self).__init__()
         self.low=low
         self.high=high
         self.total=0

     def run(self):
         for i in range(self.low,self.high):
             self.total+=i


thread1 = SummingThread(0,500000)
thread2 = SummingThread(500000,1000000)
thread1.start() # This actually causes the thread to run
thread2.start()
thread1.join()  # This waits until the thread has completed
thread2.join()  
# At this point, both threads have completed
result = thread1.total + thread2.total
print result   
   
--------------------------------   
## Example 2:
#!/usr/bin/python
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print "Starting " + self.name
        print_time(self.name, self.counter, 5)
        print "Exiting " + self.name

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print "%s: %s" % (threadName, time.ctime(time.time()))
        counter -= 1

# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# Start new Threads
thread1.start()
thread2.start()

print "Exiting Main Thread"
   
# Result
Starting Thread-1
Starting Thread-2
Exiting Main Thread
Thread-1: Thu Mar 21 09:10:03 2013
Thread-1: Thu Mar 21 09:10:04 2013
Thread-2: Thu Mar 21 09:10:04 2013
Thread-1: Thu Mar 21 09:10:05 2013
Thread-1: Thu Mar 21 09:10:06 2013
Thread-2: Thu Mar 21 09:10:06 2013
Thread-1: Thu Mar 21 09:10:07 2013
Exiting Thread-1
Thread-2: Thu Mar 21 09:10:08 2013
Thread-2: Thu Mar 21 09:10:10 2013
Thread-2: Thu Mar 21 09:10:12 2013
Exiting Thread-2   

--------------------------------
## Example 3:
#!/usr/bin/python
import threading

def main():
	print threading.active_count()	## Returns number of threading currently in active
	
if (__name__  == "__main__"):
	main()

--------------------------------------------------------------------
## Example 4: Clearly explains the need of if (__name__  == "__main__"):
## For more detatails: https://stackoverflow.com/questions/419163/what-does-if-name-main-do
## Consider you have two python codes, one.py and two.py

## file one.py ###################
def func():
    print("func() in one.py")

print("top-level in one.py")

if __name__ == "__main__":
    print("one.py is being run directly")
else:
    print("one.py is being imported into another module")
    
## file two.py  ###################
import one

print("top-level in two.py")
one.func()

if __name__ == "__main__":
    print("two.py is being run directly")
else:
    print("two.py is being imported into another module")
    
## Output of one.py
$ python one.py
top-level in one.py
one.py is being run directly

## Output of two.py
$ python two.py
top-level in one.py
one.py is being imported into another module
top-level in two.py
func() in one.py
two.py is being run directly

################################################################### Chapter17: k12Ref ##############################################
## About the below scripts
1. Create list of Sqoop Jobs by SORs (sams, lms, calms, accounts, ols)
2. Write a python script to execute the sqoop job, which accepts the jobs list as paramenter (ini file for each SOR)
3. Write a log of the above step
4. Make sure the Ini file has list of jobs separated by either , or ;
5. Schedule the python script to execute using Cron

## Crontab to trigger python script
]$ crontab -l
#DATABASE UPDATE
25 21 * * 3 python /home/oracle/k12-bigdata-automation/sqoops/sqoop-run-script.py /home/oracle/k12-bigdata-automation/database/sqoop-jobs-sams.ini
25 21 * * 4 python /home/oracle/k12-bigdata-automation/sqoops/sqoop-run-script.py /home/oracle/k12-bigdata-automation/database/sqoop-jobs-lms.ini
25 21 * * 0 python /home/oracle/k12-bigdata-automation/sqoops/sqoop-run-script.py /home/oracle/k12-bigdata-automation/database/sqoop-jobs-calms.ini
25 21 * * 1 python /home/oracle/k12-bigdata-automation/sqoops/sqoop-run-script.py /home/oracle/k12-bigdata-automation/database/sqoop-jobs-accounts.ini
10 18 * * 2 python /home/oracle/k12-bigdata-automation/sqoops/sqoop-run-script.py /home/oracle/k12-bigdata-automation/database/sqoop-jobs-ols.ini

## ini file to pass parameter to python script. All the jobs separated by comma runs in parallel and separated by ; runs in sequential
[oracle@bda1node05 database]$ cat sqoop-jobs-sams.ini
[generic_params]
log = /home/oracle/logs

[specific_params]
useCaseName=database-update
jobs=job_sams_xschoolstudent;job_sams_at_xschoolstudent;job_sams_at_school;job_sams_state,job_sams_reason;job_sams_xschrsn;job_sams_gradelevel;job_sams_at_student,job_lms_subjecttype;job_lms_currentscopeandsequences;job_lms_curriculumlookup;job_lms_scopeandsequence,job_lms_activityprogress;job_ols_person;


## Python Script
[oracle@bda1node05 sqoops]$ cat sqoop-run-script.py
#!/usr/bin/env python
import os
import sys
import subprocess
import threading
import time
from datetime import datetime
sys.path.insert(0, '/home/oracle/k12-bigdata-automation/common')
import notification


from ConfigParser import SafeConfigParser

parser = SafeConfigParser()
parser.read(sys.argv[1])

def countJobs():
    numberJobs=0
    for jobs in groupJoblist:
        numberJobs=numberJobs+len(jobs.split(';'))
    return numberJobs

# List of jobs
groupJoblist = parser.get('specific_params', 'jobs').strip().split(',')
status = [0]*countJobs()
statistics = ['']*countJobs()
folderNameFormat="%Y-%m-%d-%H-%M-%S"

class mySqoopThread (threading.Thread):
    def __init__(self, threadname, command, outfile, threadID,groupNumber):
        threading.Thread.__init__(self)
        self.threadname = threadname
        self.command = command
        self.outfile = outfile
        self.threadID = threadID
        self.groupNumber = groupNumber
    def run(self):
        global status
        global statistics
        print "Starting " + self.threadname
        start=datetime.now()
        threadstat = runsqoopthread(self.command, self.outfile)
        print threadstat
        end=datetime.now();
        status[self.threadID] = threadstat
        statistics[self.threadID] ="<tr>"+"<td>"+self.threadname+"</td>"+"<td>"+start.strftime("%Y-%m-%d %H:%M:%S")+"</td>"+"<td>"+end.strftime("%Y-%m-%d %H:%M:%S")+"</td>"+"<td>"+str(end-start)+"</td>"+"<td>"+statusLabel(threadstat)+"</td>"+"<td>"+self.threadname+"_log.err</td><td>"+str(self.groupNumber)+"</td></tr>"
        print status
        print "Exiting " + self.threadname

def loadStatisticsToHive(absolutePath,logProcess):

    p = subprocess.call("sed 's/<tr><td>/"+parser.get('specific_params', 'useCaseName').strip()+",/g' "+absolutePath+"/statistics.log | "+"sed 's/\(<[^>]*>\)/     /g' > "+absolutePath+"/statistics2.log",stdout=logProcess, stderr=logProcess, shell=True)
    p = subprocess.call("sed 's/         /,/g' "+absolutePath+"/statistics2.log > "+absolutePath+"/statistics3.log",stdout=logProcess, stderr=logProcess, shell=True)
    p = subprocess.call("hive -e \"LOAD DATA LOCAL INPATH '"+absolutePath+"/statistics3.log' "+" INTO TABLE thirdparty.sqoops_statistics\"",stdout=logProcess, stderr=logProcess, shell=True)


def runsqoopthread(command,outfile):
    logfile = open(outfile,'w')
    err_stat = runsqoop(command,logfile)
    logfile.close();
    return err_stat

def runsqoop(command,logfile):
    p = subprocess.Popen(command, stdout=logfile, stderr=logfile)
    logfile.write('Process PID is '+str(p.pid)+'\n')
    ret_code = p.wait()
    logfile.flush()
    return ret_code

def main(argv):
    global status

    startAllProcess=datetime.now();

    rootpath = parser.get('generic_params', 'log').strip()+'/'+parser.get('specific_params', 'useCaseName').strip()+'/sqoop_scripts'
    base_rootpath=rootpath
    if not os.path.exists(rootpath):
        print 'Error: directory '+rootpath+' does not exist'
        sys.exit(1)

    lastExecuting = open(rootpath+'/'+'lastExecuting.log','w')
    folderName=datetime.now();
    p = subprocess.call("mkdir "+rootpath+"/"+folderName.strftime(folderNameFormat),stdout=lastExecuting, stderr=lastExecuting, shell=True)
    rootpath=rootpath+"/"+folderName.strftime(folderNameFormat)

    executable = 'sqoop'
    tool = 'job'
    opts = '--exec'

    threads = []

    jobNumber=0;

    for i in range(0,len(groupJoblist)):

        joblist=groupJoblist[i].split(';')

        for b in range(0,len(joblist)):

             outfile = rootpath+'/'+joblist[b]+'_log.err'

             command = [executable, tool, opts, joblist[b]]

             t = mySqoopThread(joblist[b], command, outfile, jobNumber,i)
             threads.append(t)
             jobNumber=jobNumber++1
             t.start()

        for c in range(jobNumber-len(joblist),jobNumber):
            threads[c].join()


    print status
    endAllProcess=datetime.now()

    logfile = open(rootpath+'/'+'statistics.log','w')

    email=""

    for row in statistics:
        logfile.write(row+"\n")
        email=email+row

    diff=endAllProcess-startAllProcess
    final="<tr><td>Total"+"</td><td>"+startAllProcess.strftime("%Y-%m-%d %H:%M:%S")+"</td><td>"+endAllProcess.strftime("%Y-%m-%d %H:%M:%S")+"</td><td>"+str(diff)+"</td><td></td><td></td></tr>";
    logfile.write(final)
    email=email+final
    logfile.flush()
    logfile.close()
    #Compress Folder
    #p = subprocess.call("tar cvzf "+base_rootpath+"/logs.tar.gz "+rootpath,stdout=lastExecuting, stderr=lastExecuting, shell=True)

    #SendMail
    notification.sendMailWithSubject("Sqoops Scripts Execution:"+parser.get('specific_params', 'useCaseName').strip()+" Date:"+folderName.strftime(folderNameFormat),email,"sqoops-template.html");
    loadStatisticsToHive(rootpath,lastExecuting)

def statusLabel(status):
    if status == 0:
        return "Passed"
    else:
        return "failed"

if __name__ == "__main__":
    main(sys.argv[1:])


##############################################################################	
